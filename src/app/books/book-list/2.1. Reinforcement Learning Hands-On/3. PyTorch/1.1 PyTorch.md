# PyTorch

## Tensors

- **Definition**
  - In DL, a tensor is any _**multi-dimensional array**_
      - <img style="display:inline-block;width:75%;max-width:300px;" src="/books/Reinforcement Learning Hands-On/tensor.png" />
      - _In mathematics, a tensor is a mapping between vector spaces, often represented as a multi-dimensional array, but with deeper semantic meaning._
  - Types of Tensors: `torch.FloatTensor` (corresponding to a 32-bit float), `torch.ByteTensor` (an 8-bit unsigned integer), `torch.LongTensor` (a 64-bit signed integer), etc
- [**Creation**](https://docs.pytorch.org/docs/stable/torch.html#creation-ops)
  - **Scalar tensor**: 
    - `torch.tensor(72)`
      - access the value via `x.item()`
  - **All Ones/Zeros/Full Tensor**
    - `torch.zeros(size=[3, 4], dtype=torch.float32)`
    - `torch.ones(size=[3, 4])`
    - `torch.full(size=[3, 4], 3.1415)`
    - `torch.full_like(input=[[3, 4],[1,2,3]], 3.1415)`
      - `dtype` can be: `torch.int32`, `torch.float64`, etc
  - **Conversion**
    - `torch.tensor([[3,2,1], [4,5,6]], dtype=torch.int32)`
  - **Random**
    - `torch.randn(size=[2,3])`: randomly draw numbers from the standard normal distribution ($(-\infty, \infty)$)
    - `torch.rand(size=[2,3])`: random numbers from a uniform distribution on the interval $[0,1)$
- [**Attributes and Methods**](https://docs.pytorch.org/docs/stable/tensors.html#tensor-class-reference)
  - Attributes
    - `is_cuda: bool`: if the Tensor is stored on the GPU
    - `is_quantized: bool`: if the Tensor is quantized
    - `is_meta: bool`: if the Tensor is a meta tensor
    - `device: str`: where this Tensor is
    - `grad: None | Tensor`: None by default and becomes a Tensor after call to `backward()`
    - `ndim: int`: number of dimensions
    - `itemsize: int`: size in bytes of an individual element.
    - `nbytes: int`: size in bytes of the tensor, `nbytes` = `itemsize` x `nelement()`
  - Methods
    - `new_zeros()`, `new_ones()`, `new_empty()`, `new_full()`, `new_tensor()`: create new tensors that inherit properties (`dtype`, `device`, etc.) from the existing tensor
    - `abs()`: create a new tensor with absolute values
    - `cos()`, `acos()`, `sin()`, `asin()`: create a new tensor with cosine/sine, inverse cosine/sine values
    - `add(number, alpha=1)`: create a new tensor with each element equals to `original_element` + `alpha` x `number`
    - `addbmm(batch1, batch2, *, beta=1, alpha=1, out=None)`: create a new tensor by performing a batch matrix-matrix product of matrices stored in batch1 and batch2
      - $out=\beta \text{input} + \alpha \left( \sum_{i=0}^{b-1} \text{batch1}_i \space @ \space \text{batch2}_i \right)$
        - if `batch1` is a $(b×n×m)$ tensor, `batch2` is a $(b×m×p)$ tensor
        - `input` (original tensor) must be $(n×p)$, `out` will be $(n×p)$